<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>EventBus使用与分析三（源码分析之注册） | Rirsa&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前面学习了EventBus3.0的基本用法和发送黏性事件等，然而目前为止我们都是只知其然不知其所以然，出于刨根问底的好习惯，我们来详解一下EventBus的源码。 看源码就像拆线球，要先找到一个线头，然后顺着将整条线拉出来。这一次我们就按着EventBus的基本使用来看源码，">
<meta name="keywords" content="Android,EventBus,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="EventBus使用与分析三（源码分析之注册）">
<meta property="og:url" content="http://yoursite.com/2017/07/25/EventBus-third/index.html">
<meta property="og:site_name" content="Rirsa&#39;s Home">
<meta property="og:description" content="前面学习了EventBus3.0的基本用法和发送黏性事件等，然而目前为止我们都是只知其然不知其所以然，出于刨根问底的好习惯，我们来详解一下EventBus的源码。 看源码就像拆线球，要先找到一个线头，然后顺着将整条线拉出来。这一次我们就按着EventBus的基本使用来看源码，">
<meta property="og:updated_time" content="2017-07-25T10:29:37.581Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="EventBus使用与分析三（源码分析之注册）">
<meta name="twitter:description" content="前面学习了EventBus3.0的基本用法和发送黏性事件等，然而目前为止我们都是只知其然不知其所以然，出于刨根问底的好习惯，我们来详解一下EventBus的源码。 看源码就像拆线球，要先找到一个线头，然后顺着将整条线拉出来。这一次我们就按着EventBus的基本使用来看源码，">
  
    <link rel="alternate" href="/atom.xml" title="Rirsa&#39;s Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Rirsa&#39;s Home</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">每一个你不满意的现在，都有一个你没有努力的曾经。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-EventBus-third" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/25/EventBus-third/" class="article-date">
  <time datetime="2017-07-25T10:06:32.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      EventBus使用与分析三（源码分析之注册）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面学习了EventBus3.0的基本用法和发送黏性事件等，然而目前为止我们都是只知其然不知其所以然，出于刨根问底的好习惯，我们来详解一下EventBus的源码。</p>
<p>看源码就像拆线球，要先找到一个线头，然后顺着将整条线拉出来。这一次我们就按着EventBus的基本使用来看源码，<a id="more"></a>EventBus.getDefault().register(Object object)就是我们的线头。</p>
<p>先看 getDefault（）方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> defaultInstance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显而易见，这是一个单例模式，使用的是双层锁检测的线程安全的懒汉加载模式的单例（十分长的定语了，后面准备写一篇单例的博文），在第二层是否为空的检测后，对默认单例对象进行了实例化。</p>
<p>这里有个需要注意的地方，我们找到defaultInstance的定义处，看到如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</div></pre></td></tr></table></figure>
<p>定义为static自然是为了单例模式的使用，这里要说的是volatile关键字，在对对象进行实例化的时候一般要进行三步：</p>
<ol>
<li>为对象分配空间</li>
<li>构造对象</li>
<li>将引用指向对象</li>
</ol>
<p>而在实例化对象时，步骤2和步骤3的顺序是不确定的，也就是说实例化的顺序可能123或132，如果某次实例化的顺序是132，在进行完步骤3、但是还没进行步骤2时有第二条线程访问这个方法，则此时引用defaultInstance已经不为null（已经将这个引用指向了分配好的空间，但是对象还没开始构造），所以在经过第一个if判断语句时，判断不为null，则直接跳到最后将这个还没有构造好对象内容的引用返回到使用单例的地方，就会引起报错。</p>
<p>volatile关键字相当于一个简易的锁，对该引用注明volatile后，在该对象完成初始化之前不会有第二条线程访问到该对象，也就是说不管是123还是132，其他线程都要等这三步完成之后才可以使用这个对象。</p>
<p>单例分析完成，继续看源码，我们点进初始化方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_BUILDER);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，在无参的构造方法里调用了另一个有参的构造方法，继续看下去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">EventBus(EventBusBuilder builder) &#123;</div><div class="line">        subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//可根据EventType查找订阅事件</span></div><div class="line">        typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//可根据订阅者查找EventType</span></div><div class="line">        stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//用于黏性事件的缓存</span></div><div class="line">        mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>); <span class="comment">//threadCode为main的事件发送器</span></div><div class="line">        backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);<span class="comment">//threadCode为background时的事件发送器</span></div><div class="line">        asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);<span class="comment">//threadCode为async的事件发送器</span></div><div class="line">        indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</div><div class="line">        subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);<span class="comment">//查找订阅方法用的类对象，很快就会用到它</span></div><div class="line">        <span class="comment">//下面的属性都从builder中获取对应的属性值</span></div><div class="line">        logSubscriberExceptions = builder.logSubscriberExceptions;</div><div class="line">        logNoSubscriberMessages = builder.logNoSubscriberMessages;</div><div class="line">        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</div><div class="line">        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</div><div class="line">        throwSubscriberException = builder.throwSubscriberException;</div><div class="line">        eventInheritance = builder.eventInheritance;</div><div class="line">        executorService = builder.executorService;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出，这里使用了Builder模式，传入的builder对象是默认的builder对象，方法里还对类里声明的map对象和poster对象进行了初始化，具体意义可以看上面源码中写好的注释。</p>
<p>到这里EventBus的初始化完成，我们已经拿到了一个内部属性都初始化完毕的单例对象，下面顺着线头走，我们来看register方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">                subscribe(subscriber, subscriberMethod);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法中通过getClass方法获取到传入的Object的class对象subscriberClass ，然后通过之前在构造方法里初始化好的subscriberMethodFinder对象调用了findSubscriberMethods(Class&lt;?&gt; subscriberClass)方法，将subscriberClass 作为参数传了进去。</p>
<p>在看findSubscriberMethods方法的源码之前，我们先回过头看看之前构造方法里对subscriberMethodFinder对象所做的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</div></pre></td></tr></table></figure>
<p>可以看到，这里将用于EventBus对象初始化的builder对象的三个属性作为参数传进了SubscriberMethodFinder类的构造方法中，我们看一下builder的这三个参数。</p>
<p>依次点进去EventBusBuilder类，很容易看到这三个属性的初值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</div><div class="line"><span class="keyword">boolean</span> strictMethodVerification;</div><div class="line"><span class="keyword">boolean</span> ignoreGeneratedIndex;</div></pre></td></tr></table></figure>
<p>由于这里我们使用的getDefault（）方法获取的单例，用来初始化EventBus对象的是默认的EventBusBuilder对象，所以builder对象所有的属性值都是默认值，<strong>所以这里subscriberInfoIndexes值为null，后面两个boolean值为false，因此被初始化的SubscriberMethodFinder类中对应的这三个属性值也是null、false、false。这些值后面会用到。</strong></p>
<p>看完了subscriberMethodFinder 的初始化，我们再回到主线，来看看findSubscriberMethods方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class="line">        <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> subscriberMethods;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</div><div class="line">            subscriberMethods = findUsingReflection(subscriberClass);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            subscriberMethods = findUsingInfo(subscriberClass);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</div><div class="line">                    + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</div><div class="line">            <span class="keyword">return</span> subscriberMethods;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法中首先访问了一下METHOD_CACHE，从名字不难看出这是用来缓存的变量，我们点到定义处看这个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>是一个通过class对象查找订阅方法集合的缓存变量，这里我们作为第一次使用这个变量来说，此时从这个缓存里获取到的subscriberMethods 当然为null，如果不是第一次使用这个变量，而是已经有缓存在这个变量中，则subscriberMethods 不为空，直接在后面的if语句判断中被返回。</p>
<p>我们来看subscriberMethods 为空，即还没有缓存的时候，下面有一串if else语句，第一个if语句就用到了之前看到初始化这个类对象时看到的属性ignoreGeneratedIndex，此时ignoreGeneratedIndex为false，所以进入else语句，调用findUsingInfo(subscriberClass)方法为subscriberMethods赋值。</p>
<p>点进findUsingInfo(subscriberClass)方法之前，我们先来看看这个if-else语句中的这两个方法，可以看到，如果ignoreGeneratedIndex为true，则会调用findUsingReflection(subscriberClass)为subscriberMethods赋值，这两个方法有什么区别呢？从名字上看，findUsingReflection(subscriberClass)是使用反射，而findUsingInfo(subscriberClass)是使用什么呢？是使用了apt，使用apt可以在编译的时候就将订阅方法都找到，而不是在运行时找订阅方法，效率提高很多倍，但是需要添加除EventBus之外的另外一个依赖。</p>
<p>这时候可能有人奇怪了，我们之前并没有添加可以使用apt的依赖，怎么前面会调用findUsingInfo(subscriberClass)方法呢？不要慌，继续往下看。</p>
<p>我们点进findUsingInfo(subscriberClass)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        FindState findState = prepareFindState();</div><div class="line">        findState.initForSubscriber(subscriberClass);</div><div class="line">        <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</div><div class="line">            <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</div><div class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</div><div class="line">                <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</div><div class="line">                    <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</div><div class="line">                        findState.subscriberMethods.add(subscriberMethod);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                findUsingReflectionInSingleClass(findState);</div><div class="line">            &#125;</div><div class="line">            findState.moveToSuperclass();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法内一开始就用了一个之前没见过的类FindState ，我们点进去看一下，可以看到List<subscribermethod> subscriberMethods = new ArrayList&lt;&gt;()，显然是用来缓存订阅方法的集合，其他属性我们暂时看不懂是干嘛的，不慌，结合类名推测一下，这个类可能的作用是对查找订阅方法的状态进行暂时的保存。</subscribermethod></p>
<p>先不管那个类的其他属性和方法，回来这个方法，可以看到调用了prepareFindState()方法对findState对象进行赋值，我们看一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</div><div class="line">                FindState state = FIND_STATE_POOL[i];</div><div class="line">                <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">                    FIND_STATE_POOL[i] = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">return</span> state;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FindState();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法中有一个加锁的代码块，点进锁的参数FIND_STATE_POOL，可以看到这是一个FindState数组，长度是4，代码块中有一个for循环，依次从这个数组中取值，取到为null的就进行下一次循环，取到不为null的赋值给局部变量state 之后就将赋值的数组项引用赋值为null，然后将state返回。在4个长度的数组都被用完后，就会直接返回一个new对象。</p>
<p>结合变量的命名，这个过程可以叙述为：该类初始化时会初始化一个大小为4的FindState池，prepareFindState() 的作用就是依次从变量池中取地址返回，被取过的数组地址就变为null，以便下次循环时跳过这个被使用的地址返回下一个还没使用的地址。</p>
<p>可能会有人感到奇怪了，一个类对象的初始化为什么要搞得这么复杂，事实上这是作者一个十分精妙的设计，后面会有地方呼应，我们先继续往下看。</p>
<p>通过prepareFindState()方法，我们的findState对象得到了内存，然后调用了initForSubscriber(subscriberClass)方法，老规矩，看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</div><div class="line">            skipSuperClasses = <span class="keyword">false</span>;</div><div class="line">            subscriberInfo = <span class="keyword">null</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>是一个很简单的用于初始化属性的方法，注意留意这几个被赋初值的变量，后面会用到。</p>
<p>继续回到 findUsingInfo方法，到现在findState对象的属性值已经全部赋值完毕了，我们继续往下看，下面是一个while循环，判断条件是findState.clazz != null，我们立刻看到了这个熟悉的<strong>clazz</strong>，这是上一句代码中在初始化方法里被赋值的属性，这个属性在之前的初始化中被赋值subscriberClass，这里的subscriberClass还是之前register传入的object的class对象，自然不为空，所以进入循环。</p>
<p>继续往下走，可以看到调用了getSubscriberInfo(findState)对findState的subscriberInfo赋值，我们看一下getSubscriberInfo方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</div><div class="line">            SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</div><div class="line">            <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</div><div class="line">                <span class="keyword">return</span> superclassInfo;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</div><div class="line">                SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</div><div class="line">                <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> info;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法里有一堆if判断，但其实都是纸老虎，我们仔细看一下第一句if判断的条件findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null，在先前对findState的初始化中，subscriberInfo被赋的初值就是null（真的有说后面会用到这几个值，没记到的翻回去找一下然后面壁五分钟），所以第一坨if语句是进不去的。</p>
<p>再看第二坨if语句，判断语句是subscriberInfoIndexes != null，subscriberInfoIndexes 是什么呢？点一下看看，然后在SubscriberMethodFinder类的构造函数中看到了它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SubscriberMethodFinder(List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes, <span class="keyword">boolean</span> strictMethodVerification,<span class="keyword">boolean</span> ignoreGeneratedIndex) &#123;</div><div class="line">        <span class="keyword">this</span>.subscriberInfoIndexes = subscriberInfoIndexes;</div><div class="line">        <span class="keyword">this</span>.strictMethodVerification = strictMethodVerification;</div><div class="line">        <span class="keyword">this</span>.ignoreGeneratedIndex = ignoreGeneratedIndex;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>有木有很眼熟？我们在EventBus的初始化方法里用到这货啊：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</div></pre></td></tr></table></figure>
<p>再看看subscriberInfoIndexes在这里是什么，由于我们使用的是getDefault拿到的默认单例，所以subscriberInfoIndexes是null，所以第二坨if语句也进不去，直接跳到最后返回null。</p>
<p>一番波折之后，再次回到主线，可以看到返回的null被赋值给了findState的subscriberInfo对象，再下面的if语句马上对这个subscriberInfo对象进行了判断，因为subscriberInfo为空，所以跳过if语句进入了else语句，然后看看else语句里是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</div><div class="line">          SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</div><div class="line">          <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</div><div class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</div><div class="line">                    findState.subscriberMethods.add(subscriberMethod);</div><div class="line">                 &#125;</div><div class="line">          &#125;</div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line">          findUsingReflectionInSingleClass(findState);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>惊不惊喜意不意外？虽然看起来是调用了findUsingInfo方法，但还是调用了使用反射的方法，不加依赖就是不让你用apt。</p>
<p>这之后的步骤和使用反射的findUsingReflection方法后面是相同的，我们来看一下findUsingReflection方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        FindState findState = prepareFindState();</div><div class="line">        findState.initForSubscriber(subscriberClass);</div><div class="line">        <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">            findUsingReflectionInSingleClass(findState);</div><div class="line">            findState.moveToSuperclass();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>同样使用prepareFindState()对FindState分配内存，调用initForSubscriber方法对FindState对象的属性赋值，对findState的clazz判空后进入while循环，后面的步骤就和findUsingInfo相同了。</p>
<p>接下来就看看findUsingReflection和findUsingInfo两个方法在不加apt依赖的情况下都会运行到的方法    findUsingReflectionInSingleClass:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">        Method[] methods;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></div><div class="line">            methods = findState.clazz.getDeclaredMethods();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></div><div class="line">            methods = findState.clazz.getMethods();</div><div class="line">            findState.skipSuperClasses = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</div><div class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</div><div class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</div><div class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</div><div class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                    String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</div><div class="line">                            <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</div><div class="line">                        <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法体很复杂，我们一步步来。</p>
<p>首先通过反射获取方法集合，这里调用反射的是findState.clazz，根据之前分析的，这个对象被赋的值是register的时候传入的Object的class对象，所以这里可以获得注册时传入的订阅者中的所有方法组成的数组。</p>
<p>之后就是对这个方法数组的遍历，通过每个method对象的getModifiers（），判断method是否为public、是否为static或abstract方法，如果是public方法且不是static或abstract方法，则进入第一层if语句，否则报错提示必须为public、且不能是static和abstract方法。</p>
<p>这个语句中通过反射拿到了该方法的参数类型组成的数组，然后判断该数组的长度，如果数组长度是1则进入第二层if语句，否则报错提示方法必须精确地只有一个参数。不知道阅读之前两篇博客的筒子们有没有好奇过<strong>接收事件的方法里为什么不能无参或多个参数</strong>，这里从源码层面做出了解答。</p>
<p>进入第二层if语句后，通过调用method方法的getAnnotation（Subscribe.class）方法获取到方法的注解对象，然后对这个注解对象进行判空，如果不为空，则证明当前遍历到的方法为用于接收事件的注解方法，于是进入第三层if语句。</p>
<p>第三层if语句中，通过对数组的第一个元素取值拿到了方法的参数类型，也就是传递的事件类型eventType，将当前遍历到的method和获取到的eventType作为参数传入findState对象的checkAdd方法进行判断，返回true则进入第四层if语句。</p>
<p>checkAdd是FindState类中之前我们没搞清楚用处的方法之一，现在根据这里使用它的位置和它的命名就可以大概了解到，checkAdd是一个用于检查的方法，我们点进去看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">            <span class="comment">// 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span></div><div class="line">            <span class="comment">// Usually a subscriber doesn't have methods listening to the same event type.</span></div><div class="line">            Object existing = anyMethodByEventType.put(eventType, method);</div><div class="line">            <span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</div><div class="line">                    <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</div><div class="line">                        <span class="comment">// Paranoia check</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// Put any non-Method object to "consume" the existing Method</span></div><div class="line">                    anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>方法里用到了anyMethodByEventType，这是一个用HashMap实例化的map对象，可以用EventType查找订阅方法。</p>
<p>方法里首先调用了anyMethodByEventType的put方法，将参数传入的method和eventType传了进去。我们知道hashMap的put方法添加某个key-value值时，如果以前就存在相同的key，则会将用新的value值覆盖相同key的旧的value值，并将旧的value返回；而如果hashmap中原先没有这个key，则会将这个key-value存入hashmap并返回null。所以第一个if判断put方法返回值赋值的existing是否为null，为null则说明以前没有添加过这个eventType，直接返回true。</p>
<p>而如果existing不为null，则说明之前已经添加过这个eventType，代码进入else语句，判断如果existing是Method的子类，则进入else中第一个if语句，然后将<strong>被覆盖的老方法</strong>传入checkAddWithMethodSignature，开始对方法签名进行检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">            methodKeyBuilder.setLength(<span class="number">0</span>);</div><div class="line">            methodKeyBuilder.append(method.getName());</div><div class="line">            methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</div><div class="line"></div><div class="line">            String methodKey = methodKeyBuilder.toString();</div><div class="line">            Class&lt;?&gt; methodClass = method.getDeclaringClass();</div><div class="line">            Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</div><div class="line">            <span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</div><div class="line">                <span class="comment">// Only add if not already found in a sub class</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Revert the put, old class is further down the class hierarchy</span></div><div class="line">                subscriberClassByMethodKey.put(methodKey, methodClassOld);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>方法签名的构成就是方法体的前三行，通过将<strong>旧方法</strong>的方法签名和方法的class对象put进subscriberClassByMethodKey的返回值判断是否已经有了这个接收事件的方法，如果没有则返回true，如果方法重复了则再将原先因为put操作被覆盖的方法class对象put回去，然后返回false。如果这个方法返回false，则checkAdd方法抛出异常，返回true则将当前对象put进anyMethodByEventType，消耗掉对应eventType的value。最后将<strong>新传进checkAdd方法的方法</strong>传入checkAddWithMethodSignature方法，根据put进subscriberClassByMethodKey后的返回值判断是否已经有了这个方法。</p>
<p>晕了吗，反正我是转了好久才转出来。。。</p>
<p>其实简单的说，checkAdd方法就是<strong>在将订阅方法add进findState的方法集合中之前，对方法是否重复进行了一个检查</strong>，检查分了两层，第一层就是检查EventType-Method的map集合中是否有EventType，如果连这个EventType都没有这个方法就肯定没有重复；如果有重复的EventType方法也不一定是重复的啊，可能是不同的threadMode同一个EventType的方法啊，所以如果EventType相同就会进入第二层检查，即检查方法签名，方法签名就是由方法名和”&gt;”和eventType的类名构成，确定方法签名不同之后就会返回true，也就表示经过检查后可以将该方法添加到findState的方法集合中。</p>
<p>由此也看出来，我们不能定义一个方法名和事件类相同的接收事件的方法，当然你也定义不了，编译器都会直接给你报错。</p>
<p>回到调用checkAdd的地方，在checkAdd返回true，也就是经检查确定可以将该方法添加到方法集合中后，通过当前遍历到的方法的注解获取到threadMode，然后将当前方法和threadCode、priority、sticky传入订阅方法的集合，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div></pre></td></tr></table></figure>
<p>于是findUsingReflectionInSingleClass方法全部运行完成，可以看到整个方法非常复杂，总结起来就是<strong>先获取订阅者所有的方法，然后对方法进行遍历，取出public、非静态、非抽象的方法，再取出只有一个参数的方法，再取出有Subscribe注解的方法（总之就是获取到我们使用EventBus时写的@Subscribe注解的接收事件的方法），然后对方法是否重复做一个检测，最后将不重复的方法添加到做状态缓存的findState中的方法集合中。</strong></p>
<p>接下来的moveToSuperclass，是检测到如果当前类还有父类，父类中还有订阅方法，则将findState的clazz指向父类的class对象，然后重复之前获取订阅方法的过程。</p>
<p>最后看一个getMethodsAndRelease方法，方法传入了findState做参数，返回一个订阅方法的集合，是获取所有订阅方法的最后一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</div><div class="line">        findState.recycle();</div><div class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</div><div class="line">                    FIND_STATE_POOL[i] = findState;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法中用局部变量subscriberMethods 获取到findState中缓存的subscriberMethods，然后调用了findState的recycle方法，点进去不难发现，这是findState用来释放资源的方法。接下来是一个加锁的代码块，我们再次见到了FIND_STATE_POOL，这个4单位大小的FindState数组对象，然后又是一个for循环，但是这跟之前对FIND_STATE_POOL的加锁代码块中的for循环不一样了，我们再把之前的加锁代码块拿过来对比一下，那是在prepareFindState方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</div><div class="line">                FindState state = FIND_STATE_POOL[i];</div><div class="line">                <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">                    FIND_STATE_POOL[i] = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">return</span> state;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FindState();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，之前是从开头开始循环，如果检测到不为null的findState对象，就将这个对象返回赋值给调用该方法处的引用，然后将数组中的这个对象置空；而在getMethodsAndRelease方法中，同样是从开头开始对该数组遍历，然后如果检测到一个数组元素为null，则说明之前这个元素被赋值给某个findState对象了，则再这个方法中将已经释放了资源恢复默认追的findState再次赋值给为null的数组元素。<strong>这个过程就是对内存的复用，在4个findState对象之内，一直是在循环利用FIND_STATE_POOL中的内存空间</strong>。</p>
<p>将内存返回给FIND_STATE_POOL后，该方法就将局部变量暂存的方法集合返回，一路上溯，方法集合返回到了findSubscriberMethods方法的subscriberMethods中，最后对subscriberMethods做了一个是否为空的判断，如果为空则抛出异常，不为空则将这个订阅类和订阅方法作为key-value保存进METHOD_CACHE中，最后将subscriberMethods返回，于是终于又回到了EventBus类的register方法中，接下来就是对获取到的订阅方法进行一个遍历，然后将每一个方法与订阅者进行subscribe操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</div><div class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">        Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">        <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">            subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">            subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">                        + eventType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">                subscriptions.add(i, newSubscription);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">            subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">        &#125;</div><div class="line">        subscribedEvents.add(eventType);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">                <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></div><div class="line">                <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></div><div class="line">                <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></div><div class="line">                <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></div><div class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                        Object stickyEvent = entry.getValue();</div><div class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>作为register的最后一步，方法体略微有些复杂，总结来说就是将订阅者和订阅方法封装进Subscription 对象newSubscription，subscriptionsByEventType是一个能够通过EventType查找Subscription集合的map缓存，将eventType和subscription作为key-value添加进去，避免数据重复；然后通过for循环中对priority的判断，使用优先级将前面封装的newSubscription放在对应的位置。typesBySubscriber是一个可根据订阅者查找到EventType集合的map集合，通过subscriber获取到订阅事件集合后，将subscribe方法传进来的subscriberMethod的eventType添加进订阅事件集合，普通事件的订阅就结束了。</p>
<p>再下面是对黏性事件的处理，如果是黏性事件，则取出该黏性事件，然后post给当前订阅者处理。</p>
<p>至此，register流程就走完了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/25/EventBus-third/" data-id="cj664le5u00004ctuv8a6ypgi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/03/Picasso-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Picasso解析一（基本使用）
        
      </div>
    </a>
  
  
    <a href="/2017/07/20/EventBus2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">EventBus使用与解析二（黏性事件）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Picasso/">Picasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/吐槽/">吐槽</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片加载框架/">图片加载框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常/">日常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/EventBus/" style="font-size: 15px;">EventBus</a> <a href="/tags/Picasso/" style="font-size: 10px;">Picasso</a> <a href="/tags/吐槽/" style="font-size: 10px;">吐槽</a> <a href="/tags/图片加载框架/" style="font-size: 10px;">图片加载框架</a> <a href="/tags/日常/" style="font-size: 10px;">日常</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/09/life1/">吐槽及后续安排</a>
          </li>
        
          <li>
            <a href="/2017/08/03/Picasso-1/">Picasso解析一（基本使用）</a>
          </li>
        
          <li>
            <a href="/2017/07/25/EventBus-third/">EventBus使用与分析三（源码分析之注册）</a>
          </li>
        
          <li>
            <a href="/2017/07/20/EventBus2/">EventBus使用与解析二（黏性事件）</a>
          </li>
        
          <li>
            <a href="/2017/07/19/eventBus/">EventBus的使用和解析一</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Rirsa<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>